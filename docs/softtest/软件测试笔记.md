# 1. 功能测试基础理论

## 1.1 软件测试基础概念和软件测试分类

### 1.1.1 什么是软件

软件是**计算机程序,程序所用的数据**以及**有关文档资料**的集合,分为:

+ 系统软件: 是用于管理和控制计算机硬件和软件资源的软件. 如文件管理,网络管理
+ 应用软件: 用于满足特定需求的软件. 如多媒体播放器

### 1.1.2 软件测试是什么?

**软件测试**: 使用**人工和自动化**手段来**运行或测试**某个系统的**过程**.

### 1.1.3 软件测试的目的

+ 为了发现程序存在的代码或业务逻辑漏洞
+ 为了检验是否符合用户需求
+ 为了提高用户体验

### 1.1.4 软件测试分类

#### 1.1.4.1 按测试的阶段分

+ **单元测试**  

  一般由开发人员进行测试,确保各单元正确执行.一般为某个模块,或具体到类,方法.

+ **集成测试**

  将多个相关联的模块整合一起测试,为了测试模块间接口是否正确,数据是否可以传递.(如用户注册登录)

+ **系统测试**

  结合具体运行环境,将整个服务搭建起来.按照**需求规格说明书**测试软件是否符合用户需求,系统运行是否存在漏洞.

  在此阶段测试人员根据测试用例进行系统测试

+ **UAT用户验收测试**

  用户验收时进行的测试,一般分为Alpha测试和Beta测试

  + Alpha测试(内部测试) 将客户请到公司进行测试,测试环境由开发方控制.测试时间集中,测试人不多,一般为客户,测试和公司内部人员
  + Beta测试(外部测试) 公测,测试时间不集中,测试人较多

![image-20240617202619095](./_media/image-20240617202619095.png)

#### 1.1.4.2 按照测试技术(是否查看代码)分

+ **黑盒测试**

  也叫做**功能测试**,**不需要**程序内部逻辑代码,**只需要**关注外部的输入输出.

+ **白盒测试**

  也叫做**结构测试**,**只需要**关注程序内部逻辑代码,**不需要**关注外部的输入输出

+ **灰盒测试**

  也叫**半透明测试**,**既需要**关注程序内部逻辑代码,**也需要**关注外部的输入输出

![image-20240617203203351](./_media/image-20240617203203351.png)

#### 1.1.4.3 按照被测试对象是否运行分

+ **动态测试**

  运行被测试系统而进行的测试

+ **静态测试**

  不需要运行被测试系统而进行的测试(如界面检查,文档检查,code review)

#### 1.1.4.4 按照测试手段分

+ **手工测试**
+ **自动化测试**

#### 1.1.4.5 按照测试内容划分

+ **功能测试**  验证软件的业务功能是否符合需求
+ **界面测试**   系统的界面是否和原型图一致
+ **文档测试**  对系统的相关文档进行检查测试
+ **安全测试**    对系统的安全进行测试
+ **兼容性测试**  被测系统在不同环境下是否允许正常
+ **易用性测试 **  被测系统是否操作方便,容易使用
+ **性能测试(负载测试/压力测试)**    某个特定的时间,用户的数据量激增,软件是否正常

#### 1.1.4.6 其他测试分类

+ **冒烟测试**   在进行系统测试前,测试系统的主要核心功能是否正常执行
+ **回归测试**    开发对已存在的问题的功能进行修改后,再一次的测试
+ **探索性测试/自由测试**   根据自己的项目经验而进行的随意测试
+ **灰度测试**  在某项产品或应用发布前,选择**特定人群**试用,**逐步扩大**试用者数量,以便及时发现和纠错
+ **A/B测试**  新功能先给A组用户更新,看看反馈再给B组用户修改后更新使用(随机分组)

## 1.2 软件测试流程及相关文档编写规范

### 1.2.1 软件生命周期

软件生命周期(SDLC,System Development Life Cycle)是**软件开始研制**到**最终被废弃不用**所经历的各个阶段.

***软件生命周期各阶段: ***

+ **问题的定义和规划** 

  确定软件的开发目的和可行性,指定项目整体开发计划

+ **需求分析**

  在软件开发可行的情况下,对软件需要实现的各个功能进行详细的分析,明确客户的需求,最终输出**需求规格说明书终版(原型图)**,提交评审

+ **设计**

  把需求分析的结果转为软件结构和数据结构,形成系统架构

  + **概要设计** 主要是架构的实现,指搭建架构,表述各模块功能,模块接口连接和数据传递的实现等业务
  + **详细设计** 对概要设计中的表述各个模块进行深入分析,其中需要包含数据库设计

+ **编码 **

  按照设计好的模块功能表,开始编写业务模块代码

+ **软件测试**

  主要是**白盒测试**+**黑盒测试**,并按照测试计划进行:单元测试,集成测试,系统测试,验收测试

+ **运维** 运维人员进行维护,根据需求增删优化

### 1.2.2 软件生命周期模型

#### 1.2.2.1 瀑布模型

规定了他们自上而下, 相互衔接的固定次序,如同瀑布流水,逐级下落,具有依赖性和顺序性.

> **特点**: 自上而下,有顺序性
>
> **优点:**
>
> + 文档维护容易
> + 固定成本
> + 可复制性
> + 易于追踪,开发过程清晰,便于管理和控制
>
> **缺点**: 
>
> + 测试介入比较晚,导致了回溯成本高
> + 测试周期比较长
> + 不适应需求变化,一旦变化就需要重新开始整个开发过程
> + 更长的交付时间

![image-20240617205724089](./_media/image-20240617205724089.png)

#### 1.2.2.2  V/RAP/快速应用开发模型

快速应用开发(RAD, Rap Application Development),又称V模型. 它通过开发和测试同时进行的方式来缩短开发周期,提高开发效率.

> 测试在需求开始阶段就介入了
>
> **优点:**
>
> + 可以提起规划测试活动,保证测试的全面性和有效性
> + 减少重复工作,提高开发效率
> + 可以在每个开发阶段进行质量控制,确保每个阶段的质量标准得到满足
>
> **缺点:** 
>
> + 开发周期长,需要大量时间和人力资源
> + 对需求的变化敏感,一旦需求发生变化,就需要重新进行前期的规划和设计
> + 缺乏灵活性,不适应快速变化的市场

![image-20240617210411336](./_media/image-20240617210411336.png)

#### 1.2.2.3 敏捷开发模型

即将一个大项目分为多个相互联系但可以独立运行的小项目,并分别完成,使得软件一直处于可使用状态(抢占市场)

> 特点: 迭代,增量,自适应性,灵活性,协作和持续性
>
> **优点:**
>
> + 快
> + 提高用户满意度
> + 增强团队协作
> + 减少项目风险和成本
> + 提高产品质量和可维护性
>
> **缺点:**
>
> + 需求不清晰
> + 进度难以控制
> + 文档不完整
> + 容易出现技术债

![image-20240617213359273](./_media/image-20240617213359273.png)

### 1.2.3 软件测试流程(*)

#### 1.2.3.1 软件测试工作流程图

![image-20240617213537013](./_media/image-20240617213537013.png)

#### 1.2.3.2 软件测试的基本流程(*)

+ **测试需求分析阶段**

  阅读需求,理解需求,主要就是对业务的学习,分析需求点,参与需求评审会议,输出 **项目测试点列表**

+ **测试计划阶段**

  主要任务是编写**测试计划**,参考软件需求规格说明书,项目总体计划,内容包含测试范围(来自需求文档),进度的安排,人力物力的分配,整体测试的策略制,和风险评估与规避措施.

  一般由测试负责人编写

+ **测试设计阶段**

  主要是编写**测试用例**,参考需求文档(原型图),概要设计,详细设计等文档.有疑问的及时和开发,产品经理沟通.

  测试用例写完会进行**评审**

+ **测试执行阶段**

  搭建环境,执行单元测试,冒烟测试,集成测试,黑盒测试,....,回归测试,用户验收测试.并对bug进行追踪,直至解决.**输出bug**

+ **测试评估阶段**

  主要是出**测试报告**,对整个测试的过程和版本质量做一个详细的评估,确认是否可以上线

### 1.2.4 测试需求分析

#### 1.2.4.1 测试需求是什么?

测试需求主要解决"测什么"的问题,一般来自需求规格说明书中原始需求

 测试需求应全部覆盖已定义的业务流程,以及功能和非功能的测试:

**功能需求: **功能测试

**非功能需求: **界面测试,文档测试,易用性测试,安全性测试,兼容性测试,性能测试

#### 1.2.4.2 什么是软件测试需求分析

根据需求规格说明书明确测试的内容,去细分需求即提取测试点.

> 测试点: 软件包含多个功能点,每个功能点包含多个子功能(测试点). 测试点是软件功能细分的最小单元

#### 1.2.4.3 为什么需要软件测试需求

+ 软件测试需求是设计测试用例的依据
+ 有助于保证测试的质量和进度
+ 测试需求是衡量测试覆盖率的重要指标

### 1.2.5 测试用例(*)

#### 1.2.5.1 什么是软件测试用例

测试用例(TestCase)是为项目需求而编制的一组测试输入,执行条件以及预期结果,以便测试某个程序是否满足客户需求.

#### 1.2.5.2 测试用例的重要性

1. 测试用例是软件测试的核心
2. 评估测试结果的基准
3. 保证测试的时候不遗漏测试功能点.
4. 在编写测试用例的过程中可以熟悉需求,对系统架构或业务流程有一个整体的,深入的了解
5. 使得设计更加全面,具有指导性意义

#### 1.2.5.3 测试用例的八大元素(*)

+ **测试编号**  一般为**产品名-测试阶段(it集成测试,st系统测试,uat验收测试)-测试模块-序号**
+ **测试项目**  对应一个功能模块
+ **测试标题**  
+ **测试优先级**
+ **测试前置条件**
+ **测试输入**
+ **操作步骤**
+ **预期结果**
+ 实际结果
+ 备注

> **软件测试的核心是测试用例的编写**

#### 1.2.5.4 测试用例的评审

#### 1.2.5.5 测试用例划分方法(*)

##### 1.2.5.5.1 等价类划分法

一种典型的**黑盒测试**方法,**将所有可能的输入划分为N个子集合**.在该子集合中,所有的输入数据对于揭露软件中的错误都是等效的.

**等价类划分:有效等价类和无效等价类**

> 等价类划分用例设计原则:
>
> + 划分有效及无效等价类,都要为每一个等价类添加唯一的编号
> + 设计一个新的测试用例,使其**尽可能多的覆盖尚未被覆盖的有效等价类**,重复这一步,知道所有的有效等价类都被覆盖(**即用最小的用例覆盖最多的有效等价类**)
> + 设计一个新的测试用例,使其**覆盖尚未被覆盖的无效等价类**,重复这一步,知道所有的有效等价类都被覆盖(**即用最多的用例一一覆盖无效等价类**)

##### 1.2.5.5.2 边界值分析法

边界值分析法是等价类划分法的补充,边界值一般都是从等价类的边缘值去寻找.边界值分析分析的基本思想:**正好等于,刚刚小于,刚刚大于边界的值**

> 边界值的作用:大量经验得出,大量的错误一般都是在边界值的控制上
>
> 边界值的应用场景:**如果需求规定了取值范围或规定了取值的个数时,可利用边界进行测试**

##### 1.2.5.5.3 场景法

通过场景描述的**业务流程(业务逻辑),也包括代码实现逻辑**,设计用例来遍历场景(路径),验证软件系统功能的正确性.

场景法使用:

+ 画出流程图
+ **矩形框**表示步骤(操作,输入,输出结果)
+ **菱形框 **表示判断(是/否)
+ **箭头**表示流经方向

> 注意:场景法的重点是测试流程,因此每个流程用一个用例验证即可,流程测试没有问题并不能说明系统功能没有问题.**还需要针对单步功能进行测试**

##### 1.2.5.5.4 错误推测法(反推法)

基于经验和直觉推测程序中所有可能存在的各种错误,从而针对性的设计测试方法.

要素:**经验,知识,直觉**

##### 1.2.5.5.5 因果图法

##### 1.2.5.5.6 判定表法

##### 1.2.5.5.7 正交实验法

# 2.网络协议TCP/UDP

